"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2233],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=i.createContext({}),c=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return i.createElement(s.Provider,{value:t},e.children)},u="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),d=r,m=u["".concat(s,".").concat(d)]||u[d]||f[d]||a;return n?i.createElement(m,o(o({ref:t},p),{},{components:n})):i.createElement(m,o({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:r,o[1]=l;for(var c=2;c<a;c++)o[c]=n[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7706:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return u}});var i=n(7462),r=n(3366),a=(n(7294),n(3905)),o=["components"],l={title:"List of all checkers",hide_table_of_contents:!0},s=void 0,c={unversionedId:"all-checkers",id:"all-checkers",title:"List of all checkers",description:"Here is an overview of the checkers currently available in Infer.",source:"@site/docs/all-checkers.md",sourceDirName:".",slug:"/all-checkers",permalink:"/docs/next/all-checkers",draft:!1,tags:[],version:"current",frontMatter:{title:"List of all checkers",hide_table_of_contents:!0},sidebar:"docs",previous:{title:"infer run",permalink:"/docs/next/man-infer-run"},next:{title:"List of all issue types",permalink:"/docs/next/all-issue-types"}},p={},u=[{value:"Annotation Reachability",id:"annotation-reachability",level:2},{value:"Biabduction",id:"biabduction",level:2},{value:"Buffer Overrun Analysis (InferBO)",id:"buffer-overrun-analysis-inferbo",level:2},{value:"Config Impact Analysis",id:"config-impact-analysis",level:2},{value:"Cost: Complexity Analysis",id:"cost-complexity-analysis",level:2},{value:"Datalog-based points-to analysis",id:"datalog-based-points-to-analysis",level:2},{value:"Eradicate",id:"eradicate",level:2},{value:"Fragment Retains View",id:"fragment-retains-view",level:2},{value:"Immutable Cast",id:"immutable-cast",level:2},{value:"Impurity",id:"impurity",level:2},{value:"Inefficient keySet Iterator",id:"inefficient-keyset-iterator",level:2},{value:"Litho &quot;Required Props&quot;",id:"litho-required-props",level:2},{value:"Liveness",id:"liveness",level:2},{value:"Loop Hoisting",id:"loop-hoisting",level:2},{value:"Parameter Not Null Checked",id:"parameter-not-null-checked",level:2},{value:"<code>printf()</code> Argument Types",id:"printf-argument-types",level:2},{value:"Pulse",id:"pulse",level:2},{value:"Purity",id:"purity",level:2},{value:"Quandary",id:"quandary",level:2},{value:"RacerD",id:"racerd",level:2},{value:"Resource Leak Lab Exercise",id:"resource-leak-lab-exercise",level:2},{value:"Scope Leakage",id:"scope-leakage",level:2},{value:"Static Initialization Order Fiasco",id:"static-initialization-order-fiasco",level:2},{value:"SIL validation",id:"sil-validation",level:2},{value:"Lineage",id:"lineage",level:2},{value:"Self in Block",id:"self-in-block",level:2},{value:"Starvation",id:"starvation",level:2},{value:"Topl",id:"topl",level:2},{value:"Uninitialized Value",id:"uninitialized-value",level:2}],f={toc:u},d="wrapper";function m(e){var t=e.components,n=(0,r.Z)(e,o);return(0,a.kt)(d,(0,i.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Here is an overview of the checkers currently available in Infer."),(0,a.kt)("h2",{id:"annotation-reachability"},"Annotation Reachability"),(0,a.kt)("p",null,"Given a pair of source and sink annotation, e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"@PerformanceCritical")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"@Expensive"),", this checker will warn whenever some method annotated with ",(0,a.kt)("inlineCode",{parentName:"p"},"@PerformanceCritical")," calls, directly or indirectly, another method annotated with ",(0,a.kt)("inlineCode",{parentName:"p"},"@Expensive")),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-annotation-reachability"},"Visit here for more information.")),(0,a.kt)("h2",{id:"biabduction"},"Biabduction"),(0,a.kt)("p",null,"This analysis deals with a range of issues, many linked to memory safety."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-biabduction"},"Visit here for more information.")),(0,a.kt)("h2",{id:"buffer-overrun-analysis-inferbo"},"Buffer Overrun Analysis (InferBO)"),(0,a.kt)("p",null,"InferBO is a detector for out-of-bounds array accesses."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-bufferoverrun"},"Visit here for more information.")),(0,a.kt)("h2",{id:"config-impact-analysis"},"Config Impact Analysis"),(0,a.kt)("p",null,"[EXPERIMENTAL]"," Collects function that are called without config checks."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-config-impact-analysis"},"Visit here for more information.")),(0,a.kt)("h2",{id:"cost-complexity-analysis"},"Cost: Complexity Analysis"),(0,a.kt)("p",null,"Computes the asymptotic complexity of functions with respect to execution cost or other user defined resources. Can be used to detect changes in the complexity with ",(0,a.kt)("inlineCode",{parentName:"p"},"infer reportdiff"),"."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-cost"},"Visit here for more information.")),(0,a.kt)("h2",{id:"datalog-based-points-to-analysis"},"Datalog-based points-to analysis"),(0,a.kt)("p",null,"Experimental datalog-based points-to analysis."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-datalog"},"Visit here for more information.")),(0,a.kt)("h2",{id:"eradicate"},"Eradicate"),(0,a.kt)("p",null,"The eradicate ",(0,a.kt)("inlineCode",{parentName:"p"},"@Nullable")," checker for Java annotations."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"*","*","*","DEPRECATED","*","*","*")," Unmaintained and will be removed in the future. Consider using ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/uber/NullAway"},"NullAway")," as an alternative to Eradicate."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-eradicate"},"Visit here for more information.")),(0,a.kt)("h2",{id:"fragment-retains-view"},"Fragment Retains View"),(0,a.kt)("p",null,"Detects when Android fragments are not explicitly nullified before becoming unreachable."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"*","*","*","DEPRECATED","*","*","*")," Unmaintained due to poor precision."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-fragment-retains-view"},"Visit here for more information.")),(0,a.kt)("h2",{id:"immutable-cast"},"Immutable Cast"),(0,a.kt)("p",null,"Detection of object cast from immutable types to mutable types. For instance, it will detect casts from ",(0,a.kt)("inlineCode",{parentName:"p"},"ImmutableList")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"List"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"ImmutableMap")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"Map"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"ImmutableSet")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"Set"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"*","*","*","DEPRECATED","*","*","*")," Unmaintained due to poor actionability of the reports."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-immutable-cast"},"Visit here for more information.")),(0,a.kt)("h2",{id:"impurity"},"Impurity"),(0,a.kt)("p",null,'Detects functions with potential side-effects. Same as "purity", but implemented on top of Pulse.'),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-impurity"},"Visit here for more information.")),(0,a.kt)("h2",{id:"inefficient-keyset-iterator"},"Inefficient keySet Iterator"),(0,a.kt)("p",null,"Check for inefficient uses of iterators that iterate on keys then lookup their values, instead of iterating on key-value pairs directly."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-inefficient-keyset-iterator"},"Visit here for more information.")),(0,a.kt)("h2",{id:"litho-required-props"},'Litho "Required Props"'),(0,a.kt)("p",null,"Checks that all non-optional ",(0,a.kt)("inlineCode",{parentName:"p"},"@Prop"),"s have been specified when constructing Litho components."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-litho-required-props"},"Visit here for more information.")),(0,a.kt)("h2",{id:"liveness"},"Liveness"),(0,a.kt)("p",null,"Detection of dead stores and unused variables."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-liveness"},"Visit here for more information.")),(0,a.kt)("h2",{id:"loop-hoisting"},"Loop Hoisting"),(0,a.kt)("p",null,"Detect opportunities to hoist function calls that are invariant outside of loop bodies for efficiency."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-loop-hoisting"},"Visit here for more information.")),(0,a.kt)("h2",{id:"parameter-not-null-checked"},"Parameter Not Null Checked"),(0,a.kt)("p",null,"An Objective-C-specific analysis to detect when a block parameter is used before being checked for null first."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-parameter-not-null-checked"},"Visit here for more information.")),(0,a.kt)("h2",{id:"printf-argument-types"},(0,a.kt)("inlineCode",{parentName:"h2"},"printf()")," Argument Types"),(0,a.kt)("p",null,"Detect mismatches between the Java ",(0,a.kt)("inlineCode",{parentName:"p"},"printf")," format strings and the argument types For example, this checker will warn about the type error in ",(0,a.kt)("inlineCode",{parentName:"p"},'printf("Hello %d", "world")')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"*","*","*","DEPRECATED","*","*","*")," Unmaintained."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-printf-args"},"Visit here for more information.")),(0,a.kt)("h2",{id:"pulse"},"Pulse"),(0,a.kt)("p",null,"Memory and lifetime analysis."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-pulse"},"Visit here for more information.")),(0,a.kt)("h2",{id:"purity"},"Purity"),(0,a.kt)("p",null,'Detects pure (side-effect-free) functions. A different implementation of "impurity".'),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-purity"},"Visit here for more information.")),(0,a.kt)("h2",{id:"quandary"},"Quandary"),(0,a.kt)("p",null,'The Quandary taint analysis detects flows of values between sources and sinks, except if the value went through a "sanitizer". In addition to some defaults, users can specify their own sources, sinks, and sanitizers functions.'),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-quandary"},"Visit here for more information.")),(0,a.kt)("h2",{id:"racerd"},"RacerD"),(0,a.kt)("p",null,"Thread safety analysis."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-racerd"},"Visit here for more information.")),(0,a.kt)("h2",{id:"resource-leak-lab-exercise"},"Resource Leak Lab Exercise"),(0,a.kt)("p",null,'Toy checker for the "resource leak" write-your-own-checker exercise.'),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-resource-leak-lab"},"Visit here for more information.")),(0,a.kt)("h2",{id:"scope-leakage"},"Scope Leakage"),(0,a.kt)("p",null,'The Java/Kotlin checker takes into account a set of "scope" annotations and a must-not-hold relation over the scopes. The checker raises an alarm if there exists a field access path from object A to object B, with respective scopes SA and SB, such that must-not-hold(SA, SB).'),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-scope-leakage"},"Visit here for more information.")),(0,a.kt)("h2",{id:"static-initialization-order-fiasco"},"Static Initialization Order Fiasco"),(0,a.kt)("p",null,"Catches Static Initialization Order Fiascos in C++, that can lead to subtle, compiler-version-dependent errors."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-siof"},"Visit here for more information.")),(0,a.kt)("h2",{id:"sil-validation"},"SIL validation"),(0,a.kt)("p",null,"This checker validates that all SIL instructions in all procedure bodies conform to a (front-end specific) subset of SIL."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-sil-validation"},"Visit here for more information.")),(0,a.kt)("h2",{id:"lineage"},"Lineage"),(0,a.kt)("p",null,"Computes a dataflow graph"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-lineage"},"Visit here for more information.")),(0,a.kt)("h2",{id:"self-in-block"},"Self in Block"),(0,a.kt)("p",null,"An Objective-C-specific analysis to detect when a block captures ",(0,a.kt)("inlineCode",{parentName:"p"},"self"),"."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-self-in-block"},"Visit here for more information.")),(0,a.kt)("h2",{id:"starvation"},"Starvation"),(0,a.kt)("p",null,"Detect various kinds of situations when no progress is being made because of concurrency errors."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-starvation"},"Visit here for more information.")),(0,a.kt)("h2",{id:"topl"},"Topl"),(0,a.kt)("p",null,"Detect errors based on user-provided state machines describing temporal properties over multiple objects."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-topl"},"Visit here for more information.")),(0,a.kt)("h2",{id:"uninitialized-value"},"Uninitialized Value"),(0,a.kt)("p",null,"Warns when values are used before having been initialized."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"*","*","*","DEPRECATED","*","*","*")," Uninitialized value checking has moved to Pulse."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/next/checker-uninit"},"Visit here for more information.")))}m.isMDXComponent=!0}}]);